\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{mathrsfs}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usetikzlibrary{calc}
\usepackage{anyfontsize}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[margin=0.8in]{geometry}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage[linkbordercolor={1 0 0}, colorlinks=true, urlcolor=blue, linkcolor=blue]{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{titling}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{cancel}
\usepackage{xcolor}
\usepackage{mathtools}
\usepackage{float}

\usepackage{silence}
\WarningsOff[everypage]
\usepackage{background}

\usepackage{siunitx}
\usepackage{upgreek}
\usepackage{etoolbox}
\usepackage{dsfont}
\usepackage{scalerel}
\usepackage{chemformula}
\usepackage{vhistory}

\usepackage[pdftex,outline]{contour}

\setlength{\headheight}{30pt}

% background and colors

% my colors
\definecolor{myblack}{HTML}{301e2a}
\definecolor{mybblack}{HTML}{82787f}

\definecolor{myred}{HTML}{c74a77}
\definecolor{mybred}{HTML}{dbafad}

\definecolor{mygreen}{HTML}{afac7c}
\definecolor{mybgreen}{HTML}{dbd89c}

\definecolor{mypeach}{HTML}{dbb89c}
\definecolor{mybpeach}{HTML}{e9d4c3}

\definecolor{myblue}{HTML}{688894}
\definecolor{mybblue}{HTML}{a4b7be}

\definecolor{mydarkblue}{HTML}{485f67}
\definecolor{mybdarkblue}{HTML}{7e8f94}

\definecolor{mydarkred}{HTML}{772c47}
\definecolor{mybdarkred}{HTML}{9f6b7e}

\definecolor{mywhite}{HTML}{d8d7dc}
\definecolor{mybwhite}{HTML}{e7e7ea}

\definecolor{pal1}{HTML}{b52604}
\definecolor{pal2}{HTML}{e24a07}
\definecolor{pal3}{HTML}{ff9136}
\definecolor{pal4}{HTML}{0c4052}
\definecolor{pal5}{HTML}{125066}

\definecolor{sunbright}{HTML}{c8a669}
\definecolor{sun}{HTML}{ffcc33}
% my colors

% theme coloring
\colorlet{bgleftcol}{mywhite}
\colorlet{bgrightcol}{mywhite}

\definecolor{beginboxcol}{HTML}{9c9078}
\colorlet{resultboxcol}{beginboxcol!60}

\colorlet{charcoal}{myblack}
\colorlet{eqntagcol}{myblack}

\colorlet{zetrefcol}{mygreen}
\colorlet{documenttextcol}{myblack}

% title page coloring

\colorlet{coverpagetitletextcol}{mybgreen}
\colorlet{coverpagetitletextcol2}{mygreen}
\colorlet{coverpagesubtitletextcol}{mypeach}
\colorlet{coverpagenamecol}{mybpeach}
\colorlet{coverpagenamecol2}{mypeach}
\colorlet{cometoutlinecol}{mybblue}
\colorlet{cometoutlinecol2}{mybblue}

% for equation tag bolding
\newcommand\boldtag{\refstepcounter{equation}\tag*{\color{eqntagcol}{(\textbf{\theequation})}}}

\backgroundsetup{
    scale=1,
    angle=0,
    opacity=1,
    contents={\begin{tikzpicture}[remember picture,overlay]
            \path [left color = bgleftcol,middle color = bgleftcol!30, right color = bgrightcol] (current page.south west)rectangle (current page.north east);   % Adjust the position of the logo.
            % Transparent background images under the text
            % \node[opacity=0.1] {\includegraphics[scale=1]{./pumpkinbg.png}};
            % \node[opacity=0.1] {\includegraphics[scale=1]{./batsbg.png}};
        \end{tikzpicture}
    }
}

% begin macros
\newcommand{\modelterm}[1]{\textcolor{myred}{\textbf{#1}}}
\newcommand{\modeltermblue}[1]{\textcolor{myblue}{\textbf{#1}}}
\newcommand{\magicnumber}[1]{\textcolor{myred}{\textbf{#1}}}
\newcommand{\newproblem}[1]{\section*{\contour{mybblack}{\textcolor{myblack}{#1}}}}
\newcommand{\problempart}[1]{\subsection*{\contour{mybblack}{\textcolor{myblack}{#1}}}}
% end macros

% page style stuff
\pagestyle{fancyplain}
% \lhead{Doc Title}
% \rhead{Shawn Oset}



\color{documenttextcol}
% start the document already
\begin{document}

% title page
% Thanks to u/ModyTex:
% https://www.reddit.com/r/LaTeX/comments/fw9kxe/violet_cover_page_done_in_latex_check_the_first/
\pagestyle{empty}

\begin{tikzpicture}[remember picture,overlay]

\fill[charcoal] (current page.south west) rectangle (current page.north east);

\foreach \i in {2.5,...,30}
{\node[circle,draw,myblue,ultra thick,minimum size=\i cm,draw opacity=(32.5-\i)/30] at ($(current page.west)+(2.5,-5)$) {} ;}
    \node[circle,draw,minimum size=2.6 cm,fill=cometoutlinecol,cometoutlinecol] at ($(current page.west)+(2.5,-5)$) {};
    \node[circle,draw,minimum size=2.5 cm,fill=myblue,myblue] at ($(current page.west)+(2.5,-5)$) {};
    \draw[cometoutlinecol2] ($(current page.west)+(2.0,-3.85)$) arc (110:-72:1.27cm);

\begin{scope}[scale=0.35, transform shape]
\foreach \i in {2.5,...,30}
{\node[circle,draw,sun,thick,minimum size=\i cm,draw opacity=(32.5-\i)/30] at ($(current page.west)+(50,30)$) {} ;}
    \node[circle,draw,minimum size=2.6 cm,fill=sunbright,sunbright] at ($(current page.west)+(50,30)$) {};
    \node[circle,draw,minimum size=2.5 cm,fill=sun,sun] at ($(current page.west)+(50,30)$) {};
\end{scope}

\node[left,coverpagetitletextcol,minimum width=0.625*\paperwidth,minimum height=3cm, rounded corners] at ($(current page.north east)+(0,-9.5)$){{\fontsize{25}{30} \selectfont \bfseries Fragment Sputtering Comparison}};
\node[left,coverpagetitletextcol2,minimum width=0.625*\paperwidth,minimum height=3cm, rounded corners] at ($(current page.north east)+(0,-10.5)$){{\fontsize{20}{30} \selectfont \bfseries Vectorial vs. Haser}};
\node[left,coverpagesubtitletextcol,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-11.5)$){{\huge \textit{}}};
\node[left,coverpagesubtitletextcol,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-12.5)$){{\huge \textit{}}};
\node[left,coverpagenamecol,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-14)$){{\Large \textsc{Shawn Oset}}};
\node[left,coverpagenamecol2,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-15)$){{\Large \textsc{Spring 2022}}};

\end{tikzpicture}


\newpage

\newproblem{Fortran and Python Model Testing}
The python vectorial model included in sbpy is based on Festou 1981, but uses python tools and libraries, so some variation in results might be expected purely on the grounds of implementation detail.
Major disagreements between the models can happen for certain sets of parameters, particularly when the parent or fragment lifetimes are small.
These disagreements generally occur near the nucleus and near the edge of the radial grid, and this document will explain the origin of these discrepancies as shortcomings in the fortran version.

\newproblem{Vectorial Model Geometry}

\hrule
\vspace{5mm}

The vectorial model extends the Haser model primarily through its incorporation of fragment momentum changes via photodissociation.
Instead of a fragment carrying along at the parent's velocity after photodissociation as in the Haser model, the fragments are ejected isotropically in the frame of the parent with a speed determined by the physics of the photodissociation.

\problempart{Outflow Axis}

\begin{multicols}{2}
  \begin{figure}[H]
    \includegraphics[scale=0.25]{images/fragment_sputter_from_outflow_axis_transparent.png}
    \caption{Fragments traveling from the outflow axis to another point (\(r_i, \theta_j\)) in the coma.}
    \label{fig:outflow_sputter}
  \end{figure}

Due to the underlying spherical symmetry of the Haser model and the vectorial model's isotropic ejection, we need only to compute how one stream of outflowing parents distributes its fragments around the coma.

This stream of parent molecules is referred to as an \modeltermblue{outflow axis}, and the resulting distribution of fragments is called the \modelterm{fragment sputter}.

Figure \ref{fig:outflow_sputter} shows the outflow in blue on the z-axis, with the isotropic production of fragments due to photodissociation of the parents along their outflow.
The nucleus of the comet is taken to be the origin, with the spatial grid around it in red.
The fragment density at (\(r_i, \theta_j\)) is then the sum of all points of the outflow axis that contribute by ejecting a fragment at angle \(\epsilon\).
\end{multicols}

\problempart{Fragment Sputter}
To compute this fragment sputter, we place a 2d grid around the coma, with a \modelterm{radial grid} \{\(r_i\)\} and an \modelterm{angular grid} \{\(\theta_j\)\}.
At each grid point \((r_i, \theta_j)\), we calculate how heavily each point along the outflow axis contributes fragments to \((r_i, \theta_j)\).
This amounts to an integration along the outflow axis for each grid point \((r_i, \theta_j)\).

The fragments that travel the shortest distance from the outflow axis will dominate the contributions to \((r_i, \theta_j)\) due to the exponential decay from photodissociation of fragments.
There are multiple factors that influence how well the model can capture these dominating contributions:
\begin{itemize}
  \item For each \((r_i, \theta_j)\), we must sample the outflow axis around the minimum fragment travel distance more heavily for the best numerical integration results.
  % \item TODO: (Picture of finer sampling near minimum travel distance)
  \item The angular grid must be fine enough to encroach on the outflow axis and pick up fragments before they have been destroyed by photodissociation.
    The fortran model will only allow the fragments to travel for \magicnumber{8} lifetimes, so if the grid does not encroach close enough, it will miss fragments, especially at larger radii where the distance between any grid point and the outflow axis (z-axis) is large.
  % \item TODO: (Picture of two different angular grids)
  \item The radial grid must be constructed to capture the heavy contributions that occur from parents dissociating near the nucleus.
\end{itemize}

The fragment sputter from an outflow axis is the fundamental calculation that the model uses to build the radial fragment density \(n(r_{i})\) and calculate the resulting column density.
Any over- or under-estimations in the fragment sputter will show in the results, so we investigate the fragment sputter of the two models as a source of discrepancy.

\problempart{Spatial Gridding: Fortran}
The fortran version has a hard-coded grid of \(N_r = \)\magicnumber{150} radial grid points, distributed quasi-logarithmically with the point separation pre-determined by another array.
The spatial scale of the grid is based on the lifetimes of parent and fragment, and this pre-determination can affect the model negatively.
Namely, small lifetime values can cause the innermost radial grid points to lie well within the \modelterm{collision sphere (\(R_{coll}\))}, the region around the nucleus where the vectorial model is invalid.

The angular grid is also fixed with \(N_{\theta} = \)\magicnumber{26}, distributed evenly between \(\theta = 0\) and \(\theta = \pi\), limiting the ability of the model to encroach on the outflow axis at small \(\theta\) and catch fragments before photodissociation.

\problempart{Spatial Gridding: Python}
The construction of a true logarithmic radial space, with \(N_r\) configurable, is trivial with libraries like \modelterm{numpy}, so the python version can more densely sample the space near the nucleus where the fragment sputtering activity is at its highest.
Additionally, the radial grid is always started at \magicnumber{2 * \(R_{coll}\)}, or twice the collision sphere radius to avoid areas where the model is invalid.

The number of angular grid points \(N_{\theta}\) are again configurable, allowing a finer sampling of the space near the outflow axis.

\problempart{Column Density Calculation}
The integration needed to calculate the column density needs values of \(n(r)\) where \(r\) does not fall on the \modelterm{radial grid} and so we must use an interpolation scheme to produce \(n(r)\) at arbitrary values of \(r\).
Both versions use a cubic spline for approximation between grid points, but the domain is limited in the fortran version to \(R_{min} < r < R_{max}\).

To extend the approximation of \(n(r)\) to all radii, the python version will set \(n(r) = n(r_0)\) for \(r < R_{coll}\), capping the number density at the value of the grid point closest to the nucleus.
Typical values of \(R_{coll}\) are \(R_{coll} \approxeq 80 km\), while typical grid sizes extend to \(\approxeq 1,000,000\) km, so the contribution to the column density from this assumed \(n(r < R_{coll})\) is small due to the low volume encompassed inside the collision sphere.

No approximation of \(n(r)\) in the fortran model is made beyond the edge of the grid, with a simple assumption that \(n(r > R_{max}) = 0\).
To avoid this sharp cutoff in \(n(r)\) at the edge of the grid, the python model uses the total lifetime of the fragment to apply an exponential decay of the outermost grid point.

\begin{multicols}{2}
\begin{figure}[H]
  \includegraphics[scale=0.25]{images/grid_edge_col_dens_effects.png}
  \caption{Limited information for column density calculations near the edge of the grid}
  \label{fig:grid_edge}
\end{figure}
% The radial grid lines (red) can only contribute a limited amount of information at distances near the edge of the grid,
% so that the column density line of sight (yellow) can only pick up fragments
Figure \ref{fig:grid_edge} shows radial grid lines (red) with a column density line of sight path in yellow near the edge of the grid, with shade denoting regions where \(r > R_{max}\).
The fortran version takes the fragment density \(n(r)\) to be zero in the shaded region of the line of sight, while the python version will approximate in this region.

For column densities near the edge of the grid, this exponential fragment decay approximation can contribute to the python column densities being higher than fortran's.
\end{multicols}

In the cases mentioned earlier that can cause the fortran model to set radial grid points inside the collision sphere, the near-nucleus column densities will be overestimated due to the very large (but invalid) values of \(n(r)\) inside the collision sphere.

% Limiting fragment lifetime to 8 may underestimate volume and column densities when Q is large: TODO: test this

\newpage

The following figures are produced by giving both models the same input with a range of parameters to show the effects of fragment lifetime (and therefore grid size).
The runs were performed with a python grid that roughly resembled the grid of the fortran model ('matching grids') to isolate the effects of fragment lifetime, and once again with a higher-detail python grid to show that the models are converging on the same results with entirely different grids.
\newproblem{Effect of Matching Grids, Fragment Lifetime 20000 s}
\problempart{Fragment Sputter}

The fragment sputter for both models, with fortran grid in red.
Note the first fortran grid point is much closer to the nucleus, while the python grid is much more dense while staying outside the collision sphere (not marked).
It may appear as though the python version should be the overestimator here, but this fragment sputter is integrated to produce \(n(r)\), which makes the fragment sputter difficult to reason about by sight alone.

\includegraphics[scale=0.33]{images/matching/c_ftau_20000_sputter_combined.png}

\newpage
\problempart{Volume Density}
The calculated volume density \(n(r)\), showing the overestimation coming from inside the collision sphere.

\includegraphics[scale=0.4,angle=270]{images/matching/c_ftau_20000_rdens_fortran.png}

\newpage
\problempart{Column Density}
Column density, showing the fortran overestimation near the nucleus.
The short fragment lifetime keeps the python version's extra contributions from the approximation beyond the edge of the grid to a minimum, so that agreement stays good all the way out to the edge of the grid.

\includegraphics[scale=0.33]{images/matching/c_ftau_20000.png}

\newpage
\newproblem{Effect of Matching Grids, Fragment Lifetime 500000 s}

\problempart{Fragment Sputter}
The longer fragment lifetime pulls the inner edge of the fortran grid away from the nucleus, eliminating the overestimation caused in the short lifetime case.

\includegraphics[scale=0.33]{images/matching/c_ftau_500000_sputter_combined.png}

\newpage
\problempart{Volume Density}
While the fortran points are more sparse near the nucleus, the values line up well with python's, with disagreement coming from the implementation detail of fortran's fixed grid.

\includegraphics[scale=0.4,angle=270]{images/matching/c_ftau_500000_rdens_fortran.png}

\newpage
\problempart{Column Density}
Here we see much better agreement near the nucleus with some variation due to the very different radial grid spacing, which explains the erratic over/under estimation.
Further, the outer edge is seeing contributions from python approximating beyond the edge of the grid, which leads to a slightly higher column density for it at large radii.

\includegraphics[scale=0.33]{images/matching/c_ftau_500000.png}

\newpage
\newproblem{Effect of HQ Python Grid, Fragment Lifetime 20000 s}

\problempart{Fragment Sputter}

The short fragment lifetime underscores the importance of sampling the outflow axis properly: note the outer edge of the grid near the outflow axis is consistently higher in the python model as it 'catches' more fragments from the outflow axis.
This manifests in additional column density near the edge of the grid.
We expect disagreement near the nucleus as we can see the fortran model once again peeking inside the collision sphere and overestimating as a result.

\includegraphics[scale=0.33]{images/highgrid/c_ftau_20000_sputter_combined.png}

\newpage
\problempart{Volume Density}
Even with an unmatching grid, the models generally agree outside of the sources of discrepancy already discussed.

\includegraphics[scale=0.4,angle=270]{images/highgrid/c_ftau_20000_rdens_fortran.png}

\newpage
\problempart{Column Density}
We see the effects of near-nucleus overestimation and the HQ grid picking up additional fragments near the edge of the grid that the sparser fortran grid does not.

\includegraphics[scale=0.33]{images/highgrid/c_ftau_20000.png}

\newpage
\newproblem{Effect of HQ Python Grid, Fragment Lifetime 500000 s}

\problempart{Fragment Sputter}
Again the longer lifetime pulls the fortran radial grid away from the nucleus.

\includegraphics[scale=0.33]{images/highgrid/c_ftau_500000_sputter_combined.png}

\newpage
\problempart{Volume Density}
Good agreement in general despite the different gridding.

\includegraphics[scale=0.4,angle=270]{images/highgrid/c_ftau_500000_rdens_fortran.png}

\newpage
\problempart{Column Density}
The same effects as the large fragment lifetime on the matching grids: variance in the agreement near the nucleus, with a slight extra contribution near the edge of the grid from python's attempt to estimate \(n(r)\) beyond the grid.

\includegraphics[scale=0.33]{images/highgrid/c_ftau_500000.png}

\newpage
\newproblem{Summary}

Despite the two models having a different codebase and mildly different approaches, they in general agree, so there is high confidence that the python version is calculating correctly.
When they do not agree, the above comparisons and explanations should show that the deviations are from limitations in the fortran model.

\problempart{Near the Nucleus}
The failure of the fortran model to stay outside the collision sphere when fragment lifetimes are short lead to overestimations of \(\approx 10 - 20\%\) when calculating column density near the nucleus (\(r < 500,000\) km).

\problempart{Edge of the Grid}
Two contributions can cause python to have higher column densities near the edge of the grid.

By approximating beyond the edge of grid where fortran would say there are zero fragments, python will pick up more fragments (\(\approx\) 5\%).
This effect is most noticable near the edge of the grid due to the calculation of the column density as shown in Figure \ref{fig:grid_edge}.

The second contribution comes when python's angular grid is finer than fortran's, which will more accurately characterize the fragment sputter at large radii.
This effect is exaggerated at low fragment lifetimes due to the exponential decay from photodissociation -- the sparser fortran angular grid is too far away at large radii to catch fragments to the same precision, leading to a higher column density for the python version.

\end{document}
